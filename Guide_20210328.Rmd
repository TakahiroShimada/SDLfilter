---
title: "Guide to sample size assessment with SDLfilter"
date: "28/03/2021"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library(knitr)
#opts_chunk$set(echo = FALSE)
options(width = 100)
```

The main text described how the sample size of animal tracking data required to estimate animal distribution can be assessed. Here we provide a a step by step guide to the assessment based on the overlap probability using the SDLfilter R package.

For this demonstration, we use the utilisation distributions estimated for 29 flatback turtles using the adehabitatHR R package.

<br/>

#### 1. Load the package
```{r message = FALSE, results = FALSE}
library(SDLfilter); library(adehabitatHR)
```
<br/>

#### 2. Read the tracking data
```{r message = FALSE, results=FALSE}
d <- readRDS("/home/taka/Documents/Work/Research/Projects/Assessing_sample_sizes/Manuscript/Data/tracking_data.rds")
ci <- with(d, d[activity %in% "Breed" & lat > (-23) & lat < (-21.3),])
```


#### 3. Estimate UDs
```{r message = FALSE, results=FALSE}
#### 
LatLon <- data.frame(y=ci$lat, x=ci$lon)
coordinates(LatLon) <- ~x+y
proj4string(LatLon) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")
LatLon_utm <- spTransform(LatLon, CRS("+init=epsg:3577"))
sdata_HR <- cbind(sdata_HR, LatLon_utm@coords)


#### Estimating area
## range by adding 5km buffer
buff <- 5e+3
xmin <- min(sdata_HR$x) - buff; xmax <- max(sdata_HR$x) + buff
ymin <- min(sdata_HR$y) - buff; ymax <- max(sdata_HR$y) + buff

## make a grid layer
cell.size <- 1e+4
x <- seq(xmin, xmax, cell.size); y <- seq(ymin, ymax, cell.size)
xy.df <- expand.grid(x = x, y = y)
z <- rep(1, nrow(xy.df))
    
xy.coords <- SpatialPixels(SpatialPoints(xy.df))
xy.sp <- SpatialPoints(xy.coords, proj4string = CRS("+init=epsg:3577"))
xyz <- cbind(xy.df, z)
hub <- SpatialPixelsDataFrame(xy.coords, xyz)


#### Get UDs for each turtle
for(j in track.id){
    
    #### Get a subset of data for each turtle
    turtle.data<-with(sdata_HR, sdata_HR[id %in% j, ])
    
    cat(j)
    cat("\n")
    
    ## Run UD estimater
    if(nrow(turtle.data)>0){
        
        #### Creates an object of class Itraj
        data.ltraj<-with(turtle.data, as.ltraj(turtle.data[,c("x", "y")], date=DateTime, id=j, burst=j))
        
        
        ### Calculate BRB using MKDE
        ## Parameters
        TM = 12*60*60
        LM = 50
        dp = BRB.likD(data.ltraj, Tmax=TM, Lmin=LM)
        HM = 100
        
        ## Estimate utilization distribution
        ud <- BRB(data.ltraj, D=dp, Tmax=TM, Lmin=LM, hmin=HM, grid=hub, type="UD")
        

        ## Convert SpatialPixelsDataFrame to raster
        ud.raster<-raster(ud)
        
        
        ## save Raster layers
        setwd("/home/taka/Documents/Work/Research/Projects/Validating_sample_size/Outputs/UD/BRB/GPS/Raster")
        saveRDS(ud.raster, paste0("Raster_", j, ".rds"))

        ## save estUD object
        setwd("/home/taka/Documents/Work/Research/Projects/Validating_sample_size/Outputs/UD/BRB/GPS/estUD")
        saveRDS(ud, paste0("estUD_", j, ".rds"))
        
        # ## save volume contours
        # setwd("/home/taka/Documents/Work/Research/Projects/Validating_sample_size/Outputs/UD/BRB/GPS/Inter-nesting/contours")
        # #udvol<-getverticeshr(ud, standardize=TRUE, percent=95, unout="km2")
        # # saveRDS(udvol, paste(j, k, "udvol95.rds", sep="_"))
        # for(i in seq(50, 95, 5)){
        #     udvol<-getverticeshr(ud, standardize=TRUE, percent=i, unout="km2")
        #     saveRDS(udvol, paste0(j, "_", k, "_", "udvol", i, ".rds", sep=""))
        # }
        
    } else {
        cat("no data")
        cat("\n")
    }   
}
```



The input data can be either a matrix or a list of RasterLayer objects. Each row of the matrix or each RasterLayer object contains the probability distribution of an animal and each column of a matrix is associated with a unique geographical location. Therefore it is critical that the grid size and geographical extent are the consistent across UDs. For the the UDs used in this example, the grid size was 50m and the geographical extent was fixed as 1902264, 1973064, -2750440, -2653540 (EPSG:3577).

<br/>

#### 3. Calculate overlap probability from 1000 random permutation
```{r message = FALSE, results=FALSE}
overlap_prob <- UD_overlap(mydata, R = 10, method = "PHR", trim = TRUE)
```
It may take several minutes to run this code depending on the number of iterations and the machine specs. The runtime was 2 minutes 31 seconds on a linux machine (Intel i7-8650U CPU @ 1.90GHz, 32GB RAM) for 100 iterations.

<br/>

#### 4. Find the minimum sample size required to estimate the general distribution.
```{r include = FALSE, eval = FALSE}
overlap_prob <- readRDS('/home/taka/Documents/Work/Research/Projects/Assessing_sample_sizes/Outputs/Bootstraps/overlap_IN_UD100_PHR_CI_itr1000.rds')
```

```{r }
asym <- asymptote(overlap_prob)
```

As described in the main text, we considered that an asymptote had been attained once the mean index value exceeded 95% of the estimated horizontal asymptote. The sample size linked to this value was deemed to be the minimum sample size required to represent the general distribution of the group.

<br/>

#### 5. Plot the mean probability relative to the sample size and rational function fit.
```{r warning = FALSE}
ggplot(data = overlap_prob$summary)+
        geom_point(aes(x = N, y = mu), size = 1.5, alpha = 0.5) + 
        geom_path(data = asym, aes(x = N, y = ys)) +        
        scale_x_continuous(name = "N", limits = c(0.5,29)) +
        scale_y_continuous(name = "Overlap probability", limits = c(0.01,1)) +
        theme(plot.margin = margin(0,0.2,0,0.1, unit="cm"),
              plot.title = element_text(hjust = 0.5, margin=margin(0,0,0,0), size = 12),
              axis.text.x = element_text(colour="black", size=10),
              axis.text.y = element_text(colour="black", size=10))
```



This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
